#!/usr/bin/env python

# This bisection script helps isolate commits that changed a behavior of ansible.
# To use it:
#   1) check the --help output
#   2) make an ansible checkout
#   3) source hacking/env-setup before running the bisect
#   4) ansible-bisect <checkoutdir> <testsript> <args>

import os
import sys
import subprocess
import argparse
import datetime
import pickle
from distutils.version import LooseVersion
from pprint import pprint

DEVELDIR = "/var/cache/ansible/ansible.checkout.clean"
BASEDIR = "/var/cache/ansible/version_checkouts"
LOGFILE = "returncodes.txt"

def run_command(args, capture=False, shell=True, cwd=None):
    if not capture:
        p = subprocess.Popen(args, shell=True, cwd=cwd)
    else:
        p = subprocess.Popen(args, shell=True, cwd=cwd,
                             stdout=subprocess.PIPE,
                             stderr=subprocess.PIPE)
    (so, se) = p.communicate()
    return (p.returncode, so, se)

def clean_checkout(checkoutdir):
    '''Remove all .pyc files in a checkout'''
    cmd = 'find %s -type f -name "*.pyc" | xargs rm -f' % checkoutdir
    (rc, so, se) = run_command(cmd, capture=True)

def get_commits(checkoutdir):
    cmd = 'cd %s; git log --pretty=oneline' % checkoutdir
    (rc, so, se) = run_command(cmd, capture=True)
    lines = so.split('\n')
    commits = [x.strip() for x in lines if x.strip()]
    commits = [x.split()[0] for x in commits]
    #import epdb; epdb.st()
    return commits

def get_checkout_date(checkoutdir):
    xdate = None
    cmd = 'cd %s; git log -1 --pretty=fuller' % (checkoutdir)
    (rc, so, se) = run_command(cmd, capture=True)
    for x in so.split('\n'):
        if x.strip().lower().startswith('commitdate:'):
            # 'Date:   Fri Nov 11 12:48:45 2016 -0500'
            x = x.replace('CommitDate:', '', 1).strip()
            xparts = x.split()
            x = x.split('-', 1)[0].strip()
            x = x.split('+', 1)[0].strip()
            xdate = datetime.datetime.strptime(x, "%a %b %d %H:%M:%S %Y")
            break
    return xdate

def get_date_cache():
    chash = {}
    cfile = '~/.cache/ansible-commit-dates.pickle'
    cfile = os.path.expanduser(cfile)
    if os.path.isfile(cfile):
        try:
            with open(cfile, 'rb') as f:
                chash = pickle.load(f)
        except Exception as e:
            print(e)
            import epdb; epdb.st()
    return chash

def save_date_cache(chash):
    cfile = '~/.cache/ansible-commit-dates.pickle'
    cfile = os.path.expanduser(cfile)
    with open(cfile, 'wb') as f:
        pickle.dump(chash, f)

def get_commit_date(commitid, checkoutdir):
    xdate = None
    cmd = 'cd %s; git show --pretty=fuller %s' % (checkoutdir, commitid)
    (rc, so, se) = run_command(cmd, capture=True)
    for x in so.split('\n'):
        if x.strip().lower().startswith('commitdate:'):
            # 'Date:   Fri Nov 11 12:48:45 2016 -0500'
            x = x.replace('CommitDate:', '', 1).strip()
            xparts = x.split()
            x = x.split('-', 1)[0].strip()
            x = x.split('+', 1)[0].strip()
            xdate = datetime.datetime.strptime(x, "%a %b %d %H:%M:%S %Y")
            break
    return xdate

def checkout_commit(checkoutdir, githash):

    # checkout
    cmd = 'cd %s; git checkout %s' % (checkoutdir, githash)
    (rc, so, se) = run_command(cmd, capture=True)
    assert rc == 0, "unable to checkout %s" % githash

    # update submodules
    cmd = 'cd %s; git submodule update --recursive' % checkoutdir
    (rc, so, se) = run_command(cmd, capture=True)
    assert rc == 0, "unable to update submodules"

def get_version(checkoutdir, checkrc=False):
    # get the reported version
    cmd = 'source %s/hacking/env-setup ; ansible --version' % checkoutdir
    (rc, so, se) = run_command(cmd, capture=True)

    version = None
    if rc == 0:
        for x in so.split('\n'):
            if x.startswith('ansible ') or 'detached HEAD' in x:
                version = x.strip()
                version = version.split()[1].strip()
                break

    if not version and rc == 0:
        import epdb; epdb.st()

    #if version == 'egg_info':
    #    import epdb; epdb.st()

    return (rc, so, se, version)


def run_test(checkoutdir, testscript, capture=True):
    if not checkoutdir.startswith('/'):
        checkoutdir = os.path.abspath(checkoutdir)
    if not testscript.startswith('/'):
        testscript = os.path.abspath(testscript)

    cmd = 'source %s/hacking/env-setup ; %s' % (checkoutdir, testscript)
    (rc, so, se) = run_command(cmd, capture=capture, cwd=os.getcwd())
    return (rc, so, se)

def slice_dates(checkoutdir, commits, start, stop):
    '''Determine date for commits and limit to a given range'''
    start_idx = None
    stop_idx = None

    if start:
        start = datetime.datetime.strptime(start, '%Y-%m-%d')
    if stop:
        stop = datetime.datetime.strptime(stop, '%Y-%m-%d')

    # get dates for the commits
    commit_dates = get_date_cache()
    for cid,commitid in enumerate(commits):
        if commitid not in commit_dates:
            # get the date for commit
            ts = get_commit_date(commitid, checkoutdir)
            commit_dates[commitid] = ts
            print('%s %s' % (commitid, commit_dates[commitid]))

    # store dates to save time later
    save_date_cache(commit_dates)

    if start and stop:
        commits = [x for x in commits if commit_dates[x] > start and commit_dates[x] < stop]
    elif start and not stop:
        commits = [x for x in commits if commit_dates[x] > start]
    elif not start and stop:
        commits = [x for x in commits if commit_dates[x] < stop]

    #import epdb; epdb.st()
    return commits

def main():
    parser = argparse.ArgumentParser()

    parser.add_argument('checkoutdir')
    parser.add_argument('testscript')

    parser.add_argument('--direction', help="which direction to test foward|[backward]",
                        choices=['backward', 'forward'], default='backward')
    parser.add_argument('--checkrc', help="what returncode should trigger a stop (can be !<INT>)", type=str, default='1')
    parser.add_argument('--ignorerc', help="what returncodes to ignore", type=int, default=1)
    parser.add_argument('--version_start', help="what ansible version to start testing at")
    parser.add_argument('--version_stop', help="what ansible version to stop testing at")
    parser.add_argument('--date_start', help="what date to start testing at (YYYY-MM-DD)")
    parser.add_argument('--date_stop', help="what date to stop testing at (YYYY-MM-DD)")
    args = parser.parse_args()

    # fixup args
    if args.version_start:
        args.version_start = LooseVersion(args.version_start)
    if args.version_stop:
        args.version_stop = LooseVersion(args.version_stop)
    if args.checkrc.startswith('!'):
        REVERSE_CHECKOP = True
        args.checkrc = int(args.checkrc.replace('!', ''))
    else:
        REVERSE_CHECKOP = False
        args.checkrc = int(args.checkrc)

    # reset the checkout
    checkout_commit(args.checkoutdir, 'devel')

    # get all known commits
    commits = get_commits(args.checkoutdir)

    # limit commits to a date range
    if args.date_start or args.date_stop:
        print('Total commits before slicing: %s' % len(commits))
        commits = slice_dates(args.checkoutdir, commits, args.date_start, args.date_stop)
        print('Total commits after slicing: %s' % len(commits))

    # copy the list so it can be reduced
    testcommits = [x for x in commits]

    # reverse list if direction should be forward
    if args.direction == 'forward':
        commits = [x for x in reversed(commits)]
        testcommits = [x for x in reversed(testcommits)]

    BADCOMMIT = None
    MARKER1 = None
    MARKER2 = None
    STOP = False
    RESMAP = {}
    TSMAP = {}
    SKIPPED = False
    while not STOP:
        print('%s commits left to analyze' % len(testcommits))
        if not testcommits:
            sys.exit(1)
        elif len(testcommits) == 1:
            break

        if SKIPPED:
            mid = 0
        else:
            mid = len(testcommits) / 2
        cid = testcommits[mid]
        print('\t%s' % cid)
        SKIPPED = False

        # get rid of previous remnants
        clean_checkout(args.checkoutdir)
        # set the checkout version
        aversion = checkout_commit(args.checkoutdir, cid)
        # check the commit date
        cdate = get_checkout_date(args.checkoutdir)
        TSMAP[cid] = cdate
        print('\tdate: %s' % cdate)

        # get the version and use as a sanity check
        (vrc, aso, ase, aversion) = get_version(args.checkoutdir)
        if vrc != 0:
            print('\t%s' % cdate)
            print('\tsanity check failed, skipping')
            testcommits.remove(cid)
            #import epdb; epdb.st()
            SKIPPED = True
            continue
        else:
            print('\tversion: %s' % aversion)

        # move forward if too old
        aversion = LooseVersion(aversion)
        if args.version_start:
            if aversion < args.version_start:
                testcommits = testcommits[:mid]
                continue

        (rc, so, se) = run_test(args.checkoutdir, args.testscript)
        print('\trc: %s' % rc)
        RESMAP[cid] = (rc, so, se)

        '''
        if rc == 127:
            print(so)
            print(se)
            import epdb; epdb.st()
        match = False
        if args.checkrc.startswith('!'):
            # negative test
            if str(rc) != args.checkrc.replace('!', ''):
                match = True
        else:
            # postive test
            if str(rc) == args.checkrc:
                match = True
        #import epdb; epdb.st()
        '''

        #if rc != args.checkrc:
        #if not match:
        if (not REVERSE_CHECKOP and rc != args.checkrc) or (REVERSE_CHECKOP and rc == args.checkrc):
            print('\tcheckrc(%s) not found with this commit' % args.checkrc)
            MARKER1 = cid
            testcommits = testcommits[:mid+1]
            continue
        else:
            print('\tcheckrc found with this commit')
            MARKER2 = cid
            testcommits = commits[commits.index(MARKER2):commits.index(MARKER1)]
            if (len(testcommits) / 2) < 3:
                STOP = True

    if not testcommits:
        print('no commits left ...')
        if len(RESMAP) > 0:
            for item in RESMAP.items():
                print(item[0], item[1][0])
        import epdb; epdb.st()

    else:
        print('checking the last %s possible commits' % len(testcommits))

        for x in testcommits:

            if x not in TSMAP or x not in RESMAP:

                clean_checkout(args.checkoutdir)
                checkout_commit(args.checkoutdir, x)

                if x not in TSMAP:
                    cdate = get_checkout_date(args.checkoutdir)
                    TSMAP[x] = cdate
                if x not in RESMAP:
                    (rc, so, se) = run_test(args.checkoutdir, args.testscript)
                    RESMAP[x] = (rc, so, se)

            print(RESMAP[x][0], x, TSMAP[x])


if __name__ == '__main__':
    main()

