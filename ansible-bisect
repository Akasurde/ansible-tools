#!/usr/bin/env python

# This bisection script helps isolate commits that changed a behavior of ansible.
# To use it:
#   1) check the --help output
#   2) make an ansible checkout
#   3) source hacking/env-setup before running the bisect
#   4) ansible-bisect <checkoutdir> <testsript> <args>

import os
import sys
import subprocess
import argparse
import datetime
import pickle
from distutils.version import LooseVersion
from pprint import pprint

DEVELDIR = "/var/cache/ansible/ansible.checkout.clean"
BASEDIR = "/var/cache/ansible/version_checkouts"
LOGFILE = "returncodes.txt"

def run_command(args, capture=False, shell=True, cwd=None):
    if not capture:
        p = subprocess.Popen(args, shell=True, cwd=cwd)
    else:
        p = subprocess.Popen(args, shell=True, cwd=cwd,
                             stdout=subprocess.PIPE,
                             stderr=subprocess.PIPE)
    (so, se) = p.communicate()
    return (p.returncode, so, se)

def clean_checkout(checkoutdir):
    '''Remove all .pyc files in a checkout'''
    cmd = 'find %s -type f -name "*.pyc" | xargs rm -f' % checkoutdir
    (rc, so, se) = run_command(cmd, capture=True)

def get_commits(checkoutdir):
    cmd = 'cd %s; git log --pretty=oneline' % checkoutdir
    (rc, so, se) = run_command(cmd, capture=True)
    lines = so.split('\n')
    commits = [x.strip() for x in lines if x.strip()]
    commits = [x.split()[0] for x in commits]
    #import epdb; epdb.st()
    return commits

def get_checkout_date(checkoutdir):
    xdate = None
    cmd = 'cd %s; git log -1 --pretty=fuller' % (checkoutdir)
    (rc, so, se) = run_command(cmd, capture=True)
    for x in so.split('\n'):
        if x.strip().lower().startswith('commitdate:'):
            # 'Date:   Fri Nov 11 12:48:45 2016 -0500'
            x = x.replace('CommitDate:', '', 1).strip()
            xparts = x.split()
            x = x.split('-', 1)[0].strip()
            x = x.split('+', 1)[0].strip()
            xdate = datetime.datetime.strptime(x, "%a %b %d %H:%M:%S %Y")
            break
    return xdate

def get_date_cache(cachedir='.cache'):
    chash = {}
    if not os.path.isdir(cachedir):
        os.makedirs(cachedir)
    cfile = '%s/ansible-commit-dates.pickle' % cachedir
    cfile = os.path.expanduser(cfile)
    if os.path.isfile(cfile):
        try:
            with open(cfile, 'rb') as f:
                chash = pickle.load(f)
        except Exception as e:
            print(e)
            import epdb; epdb.st()
    return chash

def save_date_cache(chash, cachedir='.cache'):
    if not os.path.isdir(cachedir):
        os.makedirs(cachedir)
    cfile = '%s/ansible-commit-dates.pickle' % cachedir
    cfile = os.path.expanduser(cfile)
    with open(cfile, 'wb') as f:
        pickle.dump(chash, f)

def get_commit_date(commitid, checkoutdir):
    xdate = None
    cmd = 'cd %s; git show --pretty=fuller %s' % (checkoutdir, commitid)
    (rc, so, se) = run_command(cmd, capture=True)
    for x in so.split('\n'):
        if x.strip().lower().startswith('commitdate:'):
            # 'Date:   Fri Nov 11 12:48:45 2016 -0500'
            x = x.replace('CommitDate:', '', 1).strip()
            xparts = x.split()
            x = x.split('-', 1)[0].strip()
            x = x.split('+', 1)[0].strip()
            xdate = datetime.datetime.strptime(x, "%a %b %d %H:%M:%S %Y")
            break
    return xdate

def checkout_commit(checkoutdir, githash):

    # checkout
    cmd = 'cd %s; git checkout %s' % (checkoutdir, githash)
    (rc, so, se) = run_command(cmd, capture=True)
    assert rc == 0, "unable to checkout %s" % githash

    # update submodules
    cmd = 'cd %s; git submodule update --recursive' % checkoutdir
    (rc, so, se) = run_command(cmd, capture=True)
    assert rc == 0, "unable to update submodules"

def _get_hacking_dir(checkoutdir):
    if not os.path.isdir(os.path.join(checkoutdir, 'hacking')):
        # possibly using the submodule dir as the checkout
        hacking_dir = os.path.abspath('%s/../../../../hacking' % checkoutdir)
        if not os.path.isdir(hacking_dir):
            print('NO HACKING DIRECTORY COULD BE FOUND IN CHECKOUT!!!')
            sys.exit(1)
    else:
        hacking_dir = os.path.join(checkoutdir, 'hacking')
    return hacking_dir

def get_version(checkoutdir, checkrc=False):
    # get the reported version
    hacking_dir = _get_hacking_dir(checkoutdir)
    cmd = 'source %s/env-setup ; ansible --version' % hacking_dir
    (rc, so, se) = run_command(cmd, capture=True)

    version = None
    if rc == 0:
        for x in so.split('\n'):
            if x.startswith('ansible ') or 'detached HEAD' in x:
                version = x.strip()
                version = version.split()[1].strip()
                break

    if not version and rc == 0:
        import epdb; epdb.st()

    #if version == 'egg_info':
    #    import epdb; epdb.st()

    return (rc, so, se, version)

def run_test(checkoutdir, testscript, capture=True):
    if not checkoutdir.startswith('/'):
        checkoutdir = os.path.abspath(checkoutdir)
    if not testscript.startswith('/'):
        testscript = os.path.abspath(testscript)

    hacking_dir = _get_hacking_dir(checkoutdir)

    cmd = 'source %s/env-setup ; %s' % (hacking_dir, testscript)
    (rc, so, se) = run_command(cmd, capture=capture, cwd=os.getcwd())
    return (rc, so, se)

def slice_dates(checkoutdir, commits, start, stop):
    '''Determine date for commits and limit to a given range'''
    start_idx = None
    stop_idx = None

    if start:
        start = datetime.datetime.strptime(start, '%Y-%m-%d')
    if stop:
        stop = datetime.datetime.strptime(stop, '%Y-%m-%d')

    # get dates for the commits
    commit_dates = get_date_cache()
    for cid,commitid in enumerate(commits):
        if commitid not in commit_dates:
            # get the date for commit
            ts = get_commit_date(commitid, checkoutdir)
            commit_dates[commitid] = ts
            print('%s %s' % (commitid, commit_dates[commitid]))

    # store dates to save time later
    save_date_cache(commit_dates)

    if start and stop:
        commits = [x for x in commits if commit_dates[x] > start and commit_dates[x] < stop]
    elif start and not stop:
        commits = [x for x in commits if commit_dates[x] > start]
    elif not start and stop:
        commits = [x for x in commits if commit_dates[x] < stop]

    #import epdb; epdb.st()
    return commits

def get_current_branch(checkoutdir):
    cmd = "git branch | egrep ^* | awk '{print $2}'"
    (rc, so, se) = run_command(cmd, capture=True, cwd=checkoutdir)
    return so.strip()



class AnsibleBisector(object):
    results = {}
    commits = []
    checkrc = 0
    direction = 'backward'
    version_start = None
    version_stop = None
    date_start = None
    date_stop = None
    marker = None

    def __init__(self, commits, **kwargs):
        self.commits = commits
        self.results = {}
        self.current_index = None

    def print_status(self):
        if self.marker:
            for idx,x in enumerate(self.commits):
                if idx <= (self.marker - 10) or idx >= (self.marker + 10):
                    continue

                rc = self.results.get(x, {}).get('rc', None)
                if self.marker and idx == self.marker:
                    print('%s %s %s <-- marker' % (idx, x, rc))
                elif idx == self.current_index:
                    print('%s %s %s <-- current' % (idx, x, rc))
                else:
                    print('%s %s %s' % (idx, x, rc))
        else:
            for idx,x in enumerate(self.commits):
                rc = self.results.get(x, {}).get('rc', None)
                print('%s %s %s' % (idx, x, rc))


    def get_bisected_commit(self):
        # we should have a marker at this point
        if not self.marker:
            return None

        a = self.commits[self.marker-1]
        b = self.commits[self.marker]
        c = self.commits[self.marker+1]

        if not b in self.results or c not in self.results:
            import epdb; epdb.st()

        if self.results[b]['rc'] == self.checkrc and self.results[c]['rc'] != self.checkrc:
            #self.print_status()
            return c
        else:
            import epdb; epdb.st()


    def get_commit_to_test(self):
        # start at the middle
        if not self.current_index:
            self.current_index = len(self.commits) / 2
        chash = self.commits[self.current_index]
        if chash in self.results:
            # looped back to a tested commit
            #print('WARNING: LOOPED BACK TO %s' % self.current_index)
            #next_index = self.current_index + 1
            next_index = self.marker + 1
            next_commit = self.commits[next_index]

            if next_commit not in self.results:
                self.current_index = next_index
                return self.commits[self.current_index]
            else:
                # No more to test...
                return None
        else:
            return self.commits[self.current_index]


    def set_result(self, commit, returncode, stdout, stderr):
        if commit not in self.results:
            self.results[commit] = {'rc': None, 'so': None, 'se': None}
        self.results[commit]['rc'] = returncode
        self.results[commit]['so'] = stdout
        self.results[commit]['se'] = stderr

        # move the marker
        self.set_current_index()

    def set_current_index(self):
        last_index = self.current_index
        last_commit = self.commits[last_index]
        last_rc = self.results[last_commit]['rc']
        last_so = self.results[last_commit]['so']
        last_se = self.results[last_commit]['se']

        if last_rc == self.checkrc:
            # move forward
            self.marker = last_index
            choices = self.commits[last_index:]
            new_index = len(choices) / 2
            self.current_index = last_index + new_index
        else:
            # move backward
            if self.marker:
                choices = self.commits[self.marker:last_index]
            else:
                choices = self.commits[:last_index]
            new_index = len(choices) / 2
            if self.marker:
                self.current_index = self.marker + new_index
            else:
                self.current_index = new_index
            #import epdb; epdb.st()

        #print('current: %s' % self.current_index)



def main():
    parser = argparse.ArgumentParser()

    parser.add_argument('checkoutdir')
    parser.add_argument('testscript')

    parser.add_argument('--direction', help="which direction to test foward|[backward]",
                        choices=['backward', 'forward'], default='backward')
    parser.add_argument('--checkrc', help="what returncode should trigger a stop (can be !<INT>)", type=str, default='1')
    parser.add_argument('--ignorerc', help="what returncodes to ignore", type=int, default=1)
    parser.add_argument('--version_start', help="what ansible version to start testing at")
    parser.add_argument('--version_stop', help="what ansible version to stop testing at")
    parser.add_argument('--date_start', help="what date to start testing at (YYYY-MM-DD)")
    parser.add_argument('--date_stop', help="what date to stop testing at (YYYY-MM-DD)")
    args = parser.parse_args()

    # fixup args
    if args.version_start:
        args.version_start = LooseVersion(args.version_start)
    if args.version_stop:
        args.version_stop = LooseVersion(args.version_stop)
    if args.checkrc.startswith('!'):
        REVERSE_CHECKOP = True
        args.checkrc = int(args.checkrc.replace('!', ''))
    else:
        REVERSE_CHECKOP = False
        args.checkrc = int(args.checkrc)

    # what is the primary branch?
    cbranch = get_current_branch(args.checkoutdir)
    if cbranch.endswith('HEAD'):
        cbranch = 'HEAD'

    # reset the checkout
    checkout_commit(args.checkoutdir, cbranch)

    # get all known commits
    commits = get_commits(args.checkoutdir)

    # limit commits to a date range
    if args.date_start or args.date_stop:
        print('Total commits before slicing: %s' % len(commits))
        commits = slice_dates(args.checkoutdir, commits, args.date_start, args.date_stop)
        print('Total commits after slicing: %s' % len(commits))

    # copy the list so it can be reduced
    testcommits = [x for x in commits]

    # reverse list if direction should be forward
    if args.direction == 'backward':
        commits = [x for x in reversed(commits)]
        testcommits = [x for x in reversed(testcommits)]

    BADCOMMIT = None
    MARKER1 = None
    MARKER2 = None
    STOP = False
    RESMAP = {}
    TSMAP = {}
    SKIPPED = False
    while not STOP:
        print('%s commits left to analyze' % len(testcommits))
        if not testcommits:
            sys.exit(1)
        elif len(testcommits) == 1:
            break

        if SKIPPED:
            mid = 0
        else:
            mid = len(testcommits) / 2
        cid = testcommits[mid]
        print('\t%s' % cid)
        SKIPPED = False

        # get rid of previous remnants
        clean_checkout(args.checkoutdir)
        # set the checkout version
        aversion = checkout_commit(args.checkoutdir, cid)
        # check the commit date
        cdate = get_checkout_date(args.checkoutdir)
        TSMAP[cid] = cdate
        print('\tdate: %s' % cdate)

        # get the version and use as a sanity check
        (vrc, aso, ase, aversion) = get_version(args.checkoutdir)
        if vrc != 0:
            print('\t%s' % cdate)
            print('\tsanity check failed, skipping')
            for line in (str(aso) + str(ase)).split('\n'):
                print('\t\t%s' % line)
            testcommits.remove(cid)
            #import epdb; epdb.st()
            SKIPPED = True
            continue
        else:
            print('\tversion: %s' % aversion)

        # move forward if too old
        aversion = LooseVersion(aversion)
        if args.version_start:
            if aversion < args.version_start:
                testcommits = testcommits[:mid]
                continue

        (rc, so, se) = run_test(args.checkoutdir, args.testscript)
        print('\trc: %s' % rc)
        RESMAP[cid] = (rc, so, se)

        '''
        if rc == 127:
            print(so)
            print(se)
            import epdb; epdb.st()
        match = False
        if args.checkrc.startswith('!'):
            # negative test
            if str(rc) != args.checkrc.replace('!', ''):
                match = True
        else:
            # postive test
            if str(rc) == args.checkrc:
                match = True
        #import epdb; epdb.st()
        '''

        #if rc != args.checkrc:
        #if not match:
        if (not REVERSE_CHECKOP and rc != args.checkrc) or (REVERSE_CHECKOP and rc == args.checkrc):
            print('\tcheckrc(%s) not found with this commit' % args.checkrc)
            MARKER1 = cid
            testcommits = testcommits[:mid+1]
            continue
        else:
            print('\tcheckrc found with this commit')
            MARKER2 = cid
            testcommits = commits[commits.index(MARKER2):commits.index(MARKER1)]
            if (len(testcommits) / 2) < 3:
                STOP = True

    if not testcommits:
        print('no commits left ...')
        if len(RESMAP) > 0:
            for item in RESMAP.items():
                print(item[0], item[1][0])
        import epdb; epdb.st()

    else:
        print('checking the last %s possible commits' % len(testcommits))

        for x in testcommits:

            if x not in TSMAP or x not in RESMAP:

                clean_checkout(args.checkoutdir)
                checkout_commit(args.checkoutdir, x)

                if x not in TSMAP:
                    cdate = get_checkout_date(args.checkoutdir)
                    TSMAP[x] = cdate
                if x not in RESMAP:
                    (rc, so, se) = run_test(args.checkoutdir, args.testscript)
                    RESMAP[x] = (rc, so, se)

            print(RESMAP[x][0], x, TSMAP[x])


if __name__ == '__main__':
    main()

